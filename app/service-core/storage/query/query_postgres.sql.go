// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_postgres.sql

package query

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const cleanupOldDrafts = `-- name: CleanupOldDrafts :exec
DELETE FROM consultation_drafts
WHERE auto_saved = true
AND updated_at < $1
`

func (q *Queries) CleanupOldDrafts(ctx context.Context, updatedAt time.Time) error {
	_, err := q.db.ExecContext(ctx, cleanupOldDrafts, updatedAt)
	return err
}

const countConsultationVersions = `-- name: CountConsultationVersions :one
SELECT COUNT(*) FROM consultation_versions WHERE consultation_id = $1
`

func (q *Queries) CountConsultationVersions(ctx context.Context, consultationID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConsultationVersions, consultationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConsultationsByStatus = `-- name: CountConsultationsByStatus :one
SELECT COUNT(*) FROM consultations WHERE user_id = $1 AND status = $2
`

type CountConsultationsByStatusParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
}

func (q *Queries) CountConsultationsByStatus(ctx context.Context, arg CountConsultationsByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConsultationsByStatus, arg.UserID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countConsultationsByUser = `-- name: CountConsultationsByUser :one
SELECT COUNT(*) FROM consultations WHERE user_id = $1
`

func (q *Queries) CountConsultationsByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countConsultationsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countNotes = `-- name: CountNotes :one
select count(*) from notes where user_id = $1
`

func (q *Queries) CountNotes(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotes, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createConsultation = `-- name: CreateConsultation :one


INSERT INTO consultations (
    id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at
`

type CreateConsultationParams struct {
	ID                   uuid.UUID       `json:"id"`
	UserID               uuid.UUID       `json:"user_id"`
	ContactInfo          json.RawMessage `json:"contact_info"`
	BusinessContext      json.RawMessage `json:"business_context"`
	PainPoints           json.RawMessage `json:"pain_points"`
	GoalsObjectives      json.RawMessage `json:"goals_objectives"`
	Status               string          `json:"status"`
	CompletionPercentage int32           `json:"completion_percentage"`
}

// Consultation queries (New Schema)
// Basic CRUD operations for consultations
func (q *Queries) CreateConsultation(ctx context.Context, arg CreateConsultationParams) (Consultation, error) {
	row := q.db.QueryRowContext(ctx, createConsultation,
		arg.ID,
		arg.UserID,
		arg.ContactInfo,
		arg.BusinessContext,
		arg.PainPoints,
		arg.GoalsObjectives,
		arg.Status,
		arg.CompletionPercentage,
	)
	var i Consultation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createConsultationDraft = `-- name: CreateConsultationDraft :one

INSERT INTO consultation_drafts (
    id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes, created_at, updated_at
`

type CreateConsultationDraftParams struct {
	ID              uuid.UUID       `json:"id"`
	ConsultationID  uuid.UUID       `json:"consultation_id"`
	UserID          uuid.UUID       `json:"user_id"`
	ContactInfo     json.RawMessage `json:"contact_info"`
	BusinessContext json.RawMessage `json:"business_context"`
	PainPoints      json.RawMessage `json:"pain_points"`
	GoalsObjectives json.RawMessage `json:"goals_objectives"`
	AutoSaved       bool            `json:"auto_saved"`
	DraftNotes      sql.NullString  `json:"draft_notes"`
}

// Draft management queries
func (q *Queries) CreateConsultationDraft(ctx context.Context, arg CreateConsultationDraftParams) (ConsultationDraft, error) {
	row := q.db.QueryRowContext(ctx, createConsultationDraft,
		arg.ID,
		arg.ConsultationID,
		arg.UserID,
		arg.ContactInfo,
		arg.BusinessContext,
		arg.PainPoints,
		arg.GoalsObjectives,
		arg.AutoSaved,
		arg.DraftNotes,
	)
	var i ConsultationDraft
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.AutoSaved,
		&i.DraftNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createConsultationVersion = `-- name: CreateConsultationVersion :one

INSERT INTO consultation_versions (
    id, consultation_id, user_id, version_number, contact_info, business_context, pain_points, goals_objectives,
    status, completion_percentage, change_summary, changed_fields
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
) RETURNING id, consultation_id, user_id, version_number, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, change_summary, changed_fields, created_at
`

type CreateConsultationVersionParams struct {
	ID                   uuid.UUID       `json:"id"`
	ConsultationID       uuid.UUID       `json:"consultation_id"`
	UserID               uuid.UUID       `json:"user_id"`
	VersionNumber        int32           `json:"version_number"`
	ContactInfo          json.RawMessage `json:"contact_info"`
	BusinessContext      json.RawMessage `json:"business_context"`
	PainPoints           json.RawMessage `json:"pain_points"`
	GoalsObjectives      json.RawMessage `json:"goals_objectives"`
	Status               string          `json:"status"`
	CompletionPercentage int32           `json:"completion_percentage"`
	ChangeSummary        sql.NullString  `json:"change_summary"`
	ChangedFields        json.RawMessage `json:"changed_fields"`
}

// Version tracking queries
func (q *Queries) CreateConsultationVersion(ctx context.Context, arg CreateConsultationVersionParams) (ConsultationVersion, error) {
	row := q.db.QueryRowContext(ctx, createConsultationVersion,
		arg.ID,
		arg.ConsultationID,
		arg.UserID,
		arg.VersionNumber,
		arg.ContactInfo,
		arg.BusinessContext,
		arg.PainPoints,
		arg.GoalsObjectives,
		arg.Status,
		arg.CompletionPercentage,
		arg.ChangeSummary,
		arg.ChangedFields,
	)
	var i ConsultationVersion
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.VersionNumber,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.ChangeSummary,
		&i.ChangedFields,
		&i.CreatedAt,
	)
	return i, err
}

const deleteConsultation = `-- name: DeleteConsultation :exec
DELETE FROM consultations WHERE id = $1
`

func (q *Queries) DeleteConsultation(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteConsultation, id)
	return err
}

const deleteConsultationDraft = `-- name: DeleteConsultationDraft :exec
DELETE FROM consultation_drafts WHERE consultation_id = $1
`

func (q *Queries) DeleteConsultationDraft(ctx context.Context, consultationID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteConsultationDraft, consultationID)
	return err
}

const deleteConsultationDraftByUser = `-- name: DeleteConsultationDraftByUser :exec
DELETE FROM consultation_drafts WHERE consultation_id = $1 AND user_id = $2
`

type DeleteConsultationDraftByUserParams struct {
	ConsultationID uuid.UUID `json:"consultation_id"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteConsultationDraftByUser(ctx context.Context, arg DeleteConsultationDraftByUserParams) error {
	_, err := q.db.ExecContext(ctx, deleteConsultationDraftByUser, arg.ConsultationID, arg.UserID)
	return err
}

const deleteConsultationVersions = `-- name: DeleteConsultationVersions :exec
DELETE FROM consultation_versions WHERE consultation_id = $1
`

func (q *Queries) DeleteConsultationVersions(ctx context.Context, consultationID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteConsultationVersions, consultationID)
	return err
}

const deleteFile = `-- name: DeleteFile :exec
delete from files where id = $1
`

func (q *Queries) DeleteFile(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteFile, id)
	return err
}

const deleteNote = `-- name: DeleteNote :exec
delete from notes where id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteNote, id)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions WHERE stripe_subscription_id = $1
`

func (q *Queries) DeleteSubscription(ctx context.Context, stripeSubscriptionID string) error {
	_, err := q.db.ExecContext(ctx, deleteSubscription, stripeSubscriptionID)
	return err
}

const deleteTokens = `-- name: DeleteTokens :exec
delete from tokens where expires < current_timestamp
`

func (q *Queries) DeleteTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteTokens)
	return err
}

const getConsultation = `-- name: GetConsultation :one
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations WHERE id = $1
`

func (q *Queries) GetConsultation(ctx context.Context, id uuid.UUID) (Consultation, error) {
	row := q.db.QueryRowContext(ctx, getConsultation, id)
	var i Consultation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getConsultationByUser = `-- name: GetConsultationByUser :one
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations WHERE id = $1 AND user_id = $2
`

type GetConsultationByUserParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetConsultationByUser(ctx context.Context, arg GetConsultationByUserParams) (Consultation, error) {
	row := q.db.QueryRowContext(ctx, getConsultationByUser, arg.ID, arg.UserID)
	var i Consultation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getConsultationDraft = `-- name: GetConsultationDraft :one
SELECT id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes, created_at, updated_at FROM consultation_drafts WHERE consultation_id = $1
`

func (q *Queries) GetConsultationDraft(ctx context.Context, consultationID uuid.UUID) (ConsultationDraft, error) {
	row := q.db.QueryRowContext(ctx, getConsultationDraft, consultationID)
	var i ConsultationDraft
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.AutoSaved,
		&i.DraftNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConsultationDraftByUser = `-- name: GetConsultationDraftByUser :one
SELECT id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes, created_at, updated_at FROM consultation_drafts WHERE consultation_id = $1 AND user_id = $2
`

type GetConsultationDraftByUserParams struct {
	ConsultationID uuid.UUID `json:"consultation_id"`
	UserID         uuid.UUID `json:"user_id"`
}

func (q *Queries) GetConsultationDraftByUser(ctx context.Context, arg GetConsultationDraftByUserParams) (ConsultationDraft, error) {
	row := q.db.QueryRowContext(ctx, getConsultationDraftByUser, arg.ConsultationID, arg.UserID)
	var i ConsultationDraft
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.AutoSaved,
		&i.DraftNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getConsultationVersion = `-- name: GetConsultationVersion :one
SELECT id, consultation_id, user_id, version_number, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, change_summary, changed_fields, created_at FROM consultation_versions
WHERE consultation_id = $1 AND version_number = $2
`

type GetConsultationVersionParams struct {
	ConsultationID uuid.UUID `json:"consultation_id"`
	VersionNumber  int32     `json:"version_number"`
}

func (q *Queries) GetConsultationVersion(ctx context.Context, arg GetConsultationVersionParams) (ConsultationVersion, error) {
	row := q.db.QueryRowContext(ctx, getConsultationVersion, arg.ConsultationID, arg.VersionNumber)
	var i ConsultationVersion
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.VersionNumber,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.ChangeSummary,
		&i.ChangedFields,
		&i.CreatedAt,
	)
	return i, err
}

const getConsultationsByBusinessName = `-- name: GetConsultationsByBusinessName :many

SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
AND contact_info->>'business_name' ILIKE $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetConsultationsByBusinessNameParams struct {
	UserID      uuid.UUID       `json:"user_id"`
	ContactInfo json.RawMessage `json:"contact_info"`
	Limit       int32           `json:"limit"`
	Offset      int32           `json:"offset"`
}

// JSONB field queries for advanced filtering
func (q *Queries) GetConsultationsByBusinessName(ctx context.Context, arg GetConsultationsByBusinessNameParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, getConsultationsByBusinessName,
		arg.UserID,
		arg.ContactInfo,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConsultationsByIndustry = `-- name: GetConsultationsByIndustry :many
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
AND business_context->>'industry' = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetConsultationsByIndustryParams struct {
	UserID          uuid.UUID       `json:"user_id"`
	BusinessContext json.RawMessage `json:"business_context"`
	Limit           int32           `json:"limit"`
	Offset          int32           `json:"offset"`
}

func (q *Queries) GetConsultationsByIndustry(ctx context.Context, arg GetConsultationsByIndustryParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, getConsultationsByIndustry,
		arg.UserID,
		arg.BusinessContext,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConsultationsByUrgency = `-- name: GetConsultationsByUrgency :many
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
AND pain_points->>'urgency_level' = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetConsultationsByUrgencyParams struct {
	UserID     uuid.UUID       `json:"user_id"`
	PainPoints json.RawMessage `json:"pain_points"`
	Limit      int32           `json:"limit"`
	Offset     int32           `json:"offset"`
}

func (q *Queries) GetConsultationsByUrgency(ctx context.Context, arg GetConsultationsByUrgencyParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, getConsultationsByUrgency,
		arg.UserID,
		arg.PainPoints,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestConsultationVersion = `-- name: GetLatestConsultationVersion :one
SELECT id, consultation_id, user_id, version_number, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, change_summary, changed_fields, created_at FROM consultation_versions
WHERE consultation_id = $1
ORDER BY version_number DESC
LIMIT 1
`

func (q *Queries) GetLatestConsultationVersion(ctx context.Context, consultationID uuid.UUID) (ConsultationVersion, error) {
	row := q.db.QueryRowContext(ctx, getLatestConsultationVersion, consultationID)
	var i ConsultationVersion
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.VersionNumber,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.ChangeSummary,
		&i.ChangedFields,
		&i.CreatedAt,
	)
	return i, err
}

const getNextVersionNumber = `-- name: GetNextVersionNumber :one
SELECT COALESCE(MAX(version_number), 0) + 1
FROM consultation_versions
WHERE consultation_id = $1
`

func (q *Queries) GetNextVersionNumber(ctx context.Context, consultationID uuid.UUID) (int32, error) {
	row := q.db.QueryRowContext(ctx, getNextVersionNumber, consultationID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const insertEmail = `-- name: InsertEmail :one
insert into emails (id, user_id, email_to, email_from, email_subject, email_body) values ($1, $2, $3, $4, $5, $6) returning id, created, updated, user_id, email_to, email_from, email_subject, email_body
`

type InsertEmailParams struct {
	ID           uuid.UUID `json:"id"`
	UserID       uuid.UUID `json:"user_id"`
	EmailTo      string    `json:"email_to"`
	EmailFrom    string    `json:"email_from"`
	EmailSubject string    `json:"email_subject"`
	EmailBody    string    `json:"email_body"`
}

func (q *Queries) InsertEmail(ctx context.Context, arg InsertEmailParams) (Email, error) {
	row := q.db.QueryRowContext(ctx, insertEmail,
		arg.ID,
		arg.UserID,
		arg.EmailTo,
		arg.EmailFrom,
		arg.EmailSubject,
		arg.EmailBody,
	)
	var i Email
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.EmailTo,
		&i.EmailFrom,
		&i.EmailSubject,
		&i.EmailBody,
	)
	return i, err
}

const insertEmailAttachment = `-- name: InsertEmailAttachment :one
insert into email_attachments (id, email_id, file_name, content_type) values ($1, $2, $3, $4) returning id, created, email_id, file_name, content_type
`

type InsertEmailAttachmentParams struct {
	ID          uuid.UUID `json:"id"`
	EmailID     uuid.UUID `json:"email_id"`
	FileName    string    `json:"file_name"`
	ContentType string    `json:"content_type"`
}

func (q *Queries) InsertEmailAttachment(ctx context.Context, arg InsertEmailAttachmentParams) (EmailAttachment, error) {
	row := q.db.QueryRowContext(ctx, insertEmailAttachment,
		arg.ID,
		arg.EmailID,
		arg.FileName,
		arg.ContentType,
	)
	var i EmailAttachment
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.EmailID,
		&i.FileName,
		&i.ContentType,
	)
	return i, err
}

const insertFile = `-- name: InsertFile :one
insert into files (id, user_id, file_key, file_name, file_size, content_type) values ($1, $2, $3, $4, $5, $6) returning id, created, updated, user_id, file_key, file_name, file_size, content_type
`

type InsertFileParams struct {
	ID          uuid.UUID `json:"id"`
	UserID      uuid.UUID `json:"user_id"`
	FileKey     string    `json:"file_key"`
	FileName    string    `json:"file_name"`
	FileSize    int64     `json:"file_size"`
	ContentType string    `json:"content_type"`
}

func (q *Queries) InsertFile(ctx context.Context, arg InsertFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, insertFile,
		arg.ID,
		arg.UserID,
		arg.FileKey,
		arg.FileName,
		arg.FileSize,
		arg.ContentType,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.FileKey,
		&i.FileName,
		&i.FileSize,
		&i.ContentType,
	)
	return i, err
}

const insertNote = `-- name: InsertNote :one
insert into notes (id, user_id, title, category, content) values ($1, $2, $3, $4, $5) returning id, created, updated, user_id, title, category, content
`

type InsertNoteParams struct {
	ID       uuid.UUID `json:"id"`
	UserID   uuid.UUID `json:"user_id"`
	Title    string    `json:"title"`
	Category string    `json:"category"`
	Content  string    `json:"content"`
}

func (q *Queries) InsertNote(ctx context.Context, arg InsertNoteParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, insertNote,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Category,
		arg.Content,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.Title,
		&i.Category,
		&i.Content,
	)
	return i, err
}

const insertToken = `-- name: InsertToken :one
insert into tokens (id, expires, target, callback) values ($1, $2, $3, $4) returning id, expires, target, callback
`

type InsertTokenParams struct {
	ID       string    `json:"id"`
	Expires  time.Time `json:"expires"`
	Target   string    `json:"target"`
	Callback string    `json:"callback"`
}

func (q *Queries) InsertToken(ctx context.Context, arg InsertTokenParams) (Token, error) {
	row := q.db.QueryRowContext(ctx, insertToken,
		arg.ID,
		arg.Expires,
		arg.Target,
		arg.Callback,
	)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Expires,
		&i.Target,
		&i.Callback,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
insert into users (id, email, access, sub, avatar, api_key) values ($1, $2, $3, $4, $5, $6) returning id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key
`

type InsertUserParams struct {
	ID     uuid.UUID `json:"id"`
	Email  string    `json:"email"`
	Access int64     `json:"access"`
	Sub    string    `json:"sub"`
	Avatar string    `json:"avatar"`
	ApiKey string    `json:"api_key"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.Access,
		arg.Sub,
		arg.Avatar,
		arg.ApiKey,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
		&i.ApiKey,
	)
	return i, err
}

const listConsultationVersions = `-- name: ListConsultationVersions :many
SELECT id, consultation_id, user_id, version_number, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, change_summary, changed_fields, created_at FROM consultation_versions
WHERE consultation_id = $1
ORDER BY version_number DESC
LIMIT $2 OFFSET $3
`

type ListConsultationVersionsParams struct {
	ConsultationID uuid.UUID `json:"consultation_id"`
	Limit          int32     `json:"limit"`
	Offset         int32     `json:"offset"`
}

func (q *Queries) ListConsultationVersions(ctx context.Context, arg ListConsultationVersionsParams) ([]ConsultationVersion, error) {
	rows, err := q.db.QueryContext(ctx, listConsultationVersions, arg.ConsultationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConsultationVersion
	for rows.Next() {
		var i ConsultationVersion
		if err := rows.Scan(
			&i.ID,
			&i.ConsultationID,
			&i.UserID,
			&i.VersionNumber,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.ChangeSummary,
			&i.ChangedFields,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConsultationsByCompletion = `-- name: ListConsultationsByCompletion :many
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
AND completion_percentage BETWEEN $2 AND $3
ORDER BY completion_percentage DESC, created_at DESC
LIMIT $4 OFFSET $5
`

type ListConsultationsByCompletionParams struct {
	UserID                 uuid.UUID `json:"user_id"`
	CompletionPercentage   int32     `json:"completion_percentage"`
	CompletionPercentage_2 int32     `json:"completion_percentage_2"`
	Limit                  int32     `json:"limit"`
	Offset                 int32     `json:"offset"`
}

func (q *Queries) ListConsultationsByCompletion(ctx context.Context, arg ListConsultationsByCompletionParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, listConsultationsByCompletion,
		arg.UserID,
		arg.CompletionPercentage,
		arg.CompletionPercentage_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConsultationsByDateRange = `-- name: ListConsultationsByDateRange :many
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
AND created_at BETWEEN $2 AND $3
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListConsultationsByDateRangeParams struct {
	UserID      uuid.UUID `json:"user_id"`
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListConsultationsByDateRange(ctx context.Context, arg ListConsultationsByDateRangeParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, listConsultationsByDateRange,
		arg.UserID,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConsultationsByStatus = `-- name: ListConsultationsByStatus :many
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListConsultationsByStatusParams struct {
	UserID uuid.UUID `json:"user_id"`
	Status string    `json:"status"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListConsultationsByStatus(ctx context.Context, arg ListConsultationsByStatusParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, listConsultationsByStatus,
		arg.UserID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConsultationsByUser = `-- name: ListConsultationsByUser :many

SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListConsultationsByUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

// Consultation listing and filtering
func (q *Queries) ListConsultationsByUser(ctx context.Context, arg ListConsultationsByUserParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, listConsultationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchConsultations = `-- name: SearchConsultations :many
SELECT id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at FROM consultations
WHERE user_id = $1
AND (
    contact_info->>'business_name' ILIKE $2 OR
    contact_info->>'contact_person' ILIKE $2 OR
    business_context->>'industry' ILIKE $2
)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type SearchConsultationsParams struct {
	UserID      uuid.UUID       `json:"user_id"`
	ContactInfo json.RawMessage `json:"contact_info"`
	Limit       int32           `json:"limit"`
	Offset      int32           `json:"offset"`
}

func (q *Queries) SearchConsultations(ctx context.Context, arg SearchConsultationsParams) ([]Consultation, error) {
	rows, err := q.db.QueryContext(ctx, searchConsultations,
		arg.UserID,
		arg.ContactInfo,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Consultation
	for rows.Next() {
		var i Consultation
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ContactInfo,
			&i.BusinessContext,
			&i.PainPoints,
			&i.GoalsObjectives,
			&i.Status,
			&i.CompletionPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectEmailAttachments = `-- name: SelectEmailAttachments :many
select id, created, email_id, file_name, content_type from email_attachments where email_id = $1
`

func (q *Queries) SelectEmailAttachments(ctx context.Context, emailID uuid.UUID) ([]EmailAttachment, error) {
	rows, err := q.db.QueryContext(ctx, selectEmailAttachments, emailID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmailAttachment
	for rows.Next() {
		var i EmailAttachment
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.EmailID,
			&i.FileName,
			&i.ContentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectEmails = `-- name: SelectEmails :many
select id, created, updated, user_id, email_to, email_from, email_subject, email_body from emails where user_id = $1
`

func (q *Queries) SelectEmails(ctx context.Context, userID uuid.UUID) ([]Email, error) {
	rows, err := q.db.QueryContext(ctx, selectEmails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Email
	for rows.Next() {
		var i Email
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.UserID,
			&i.EmailTo,
			&i.EmailFrom,
			&i.EmailSubject,
			&i.EmailBody,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectFile = `-- name: SelectFile :one
select id, created, updated, user_id, file_key, file_name, file_size, content_type from files where id = $1
`

func (q *Queries) SelectFile(ctx context.Context, id uuid.UUID) (File, error) {
	row := q.db.QueryRowContext(ctx, selectFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.FileKey,
		&i.FileName,
		&i.FileSize,
		&i.ContentType,
	)
	return i, err
}

const selectFiles = `-- name: SelectFiles :many
select id, created, updated, user_id, file_key, file_name, file_size, content_type from files where user_id = $1
`

func (q *Queries) SelectFiles(ctx context.Context, userID uuid.UUID) ([]File, error) {
	rows, err := q.db.QueryContext(ctx, selectFiles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.UserID,
			&i.FileKey,
			&i.FileName,
			&i.FileSize,
			&i.ContentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNote = `-- name: SelectNote :one
select id, created, updated, user_id, title, category, content from notes where id = $1
`

func (q *Queries) SelectNote(ctx context.Context, id uuid.UUID) (Note, error) {
	row := q.db.QueryRowContext(ctx, selectNote, id)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.Title,
		&i.Category,
		&i.Content,
	)
	return i, err
}

const selectNotes = `-- name: SelectNotes :many
select id, created, updated, user_id, title, category, content from notes where user_id = $1 order by created desc limit $2 offset $3
`

type SelectNotesParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) SelectNotes(ctx context.Context, arg SelectNotesParams) ([]Note, error) {
	rows, err := q.db.QueryContext(ctx, selectNotes, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.UserID,
			&i.Title,
			&i.Category,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSubscriptionByStripeID = `-- name: SelectSubscriptionByStripeID :one
SELECT id, created, updated, user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, current_period_start, current_period_end, canceled_at FROM subscriptions WHERE stripe_subscription_id = $1
`

func (q *Queries) SelectSubscriptionByStripeID(ctx context.Context, stripeSubscriptionID string) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, selectSubscriptionByStripeID, stripeSubscriptionID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripePriceID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CanceledAt,
	)
	return i, err
}

const selectSubscriptionByUserID = `-- name: SelectSubscriptionByUserID :one

SELECT id, created, updated, user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, current_period_start, current_period_end, canceled_at FROM subscriptions WHERE user_id = $1 AND status = 'active' ORDER BY created DESC LIMIT 1
`

// Subscription queries
func (q *Queries) SelectSubscriptionByUserID(ctx context.Context, userID uuid.UUID) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, selectSubscriptionByUserID, userID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripePriceID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CanceledAt,
	)
	return i, err
}

const selectSubscriptionsByCustomerID = `-- name: SelectSubscriptionsByCustomerID :many
SELECT id, created, updated, user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, current_period_start, current_period_end, canceled_at FROM subscriptions WHERE stripe_customer_id = $1 ORDER BY created DESC
`

func (q *Queries) SelectSubscriptionsByCustomerID(ctx context.Context, stripeCustomerID string) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, selectSubscriptionsByCustomerID, stripeCustomerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subscription
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.UserID,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.StripePriceID,
			&i.Status,
			&i.CurrentPeriodStart,
			&i.CurrentPeriodEnd,
			&i.CanceledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectToken = `-- name: SelectToken :one
select id, expires, target, callback from tokens where id = $1
`

func (q *Queries) SelectToken(ctx context.Context, id string) (Token, error) {
	row := q.db.QueryRowContext(ctx, selectToken, id)
	var i Token
	err := row.Scan(
		&i.ID,
		&i.Expires,
		&i.Target,
		&i.Callback,
	)
	return i, err
}

const selectUser = `-- name: SelectUser :one
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key from users where id = $1
`

func (q *Queries) SelectUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
		&i.ApiKey,
	)
	return i, err
}

const selectUserByCustomerID = `-- name: SelectUserByCustomerID :one
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key from users where customer_id = $1
`

func (q *Queries) SelectUserByCustomerID(ctx context.Context, customerID string) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUserByCustomerID, customerID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
		&i.ApiKey,
	)
	return i, err
}

const selectUserByEmailAndSub = `-- name: SelectUserByEmailAndSub :one
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key from users where email = $1 and sub = $2
`

type SelectUserByEmailAndSubParams struct {
	Email string `json:"email"`
	Sub   string `json:"sub"`
}

func (q *Queries) SelectUserByEmailAndSub(ctx context.Context, arg SelectUserByEmailAndSubParams) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUserByEmailAndSub, arg.Email, arg.Sub)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
		&i.ApiKey,
	)
	return i, err
}

const selectUsers = `-- name: SelectUsers :many
select id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key from users
`

func (q *Queries) SelectUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, selectUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Created,
			&i.Updated,
			&i.Email,
			&i.Phone,
			&i.Access,
			&i.Sub,
			&i.Avatar,
			&i.CustomerID,
			&i.SubscriptionID,
			&i.SubscriptionEnd,
			&i.ApiKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConsultation = `-- name: UpdateConsultation :one
UPDATE consultations SET
    contact_info = $2,
    business_context = $3,
    pain_points = $4,
    goals_objectives = $5,
    status = $6,
    completion_percentage = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at
`

type UpdateConsultationParams struct {
	ID                   uuid.UUID       `json:"id"`
	ContactInfo          json.RawMessage `json:"contact_info"`
	BusinessContext      json.RawMessage `json:"business_context"`
	PainPoints           json.RawMessage `json:"pain_points"`
	GoalsObjectives      json.RawMessage `json:"goals_objectives"`
	Status               string          `json:"status"`
	CompletionPercentage int32           `json:"completion_percentage"`
}

func (q *Queries) UpdateConsultation(ctx context.Context, arg UpdateConsultationParams) (Consultation, error) {
	row := q.db.QueryRowContext(ctx, updateConsultation,
		arg.ID,
		arg.ContactInfo,
		arg.BusinessContext,
		arg.PainPoints,
		arg.GoalsObjectives,
		arg.Status,
		arg.CompletionPercentage,
	)
	var i Consultation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const updateConsultationDraft = `-- name: UpdateConsultationDraft :one
UPDATE consultation_drafts SET
    contact_info = $2,
    business_context = $3,
    pain_points = $4,
    goals_objectives = $5,
    auto_saved = $6,
    draft_notes = $7,
    updated_at = CURRENT_TIMESTAMP
WHERE consultation_id = $1
RETURNING id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes, created_at, updated_at
`

type UpdateConsultationDraftParams struct {
	ConsultationID  uuid.UUID       `json:"consultation_id"`
	ContactInfo     json.RawMessage `json:"contact_info"`
	BusinessContext json.RawMessage `json:"business_context"`
	PainPoints      json.RawMessage `json:"pain_points"`
	GoalsObjectives json.RawMessage `json:"goals_objectives"`
	AutoSaved       bool            `json:"auto_saved"`
	DraftNotes      sql.NullString  `json:"draft_notes"`
}

func (q *Queries) UpdateConsultationDraft(ctx context.Context, arg UpdateConsultationDraftParams) (ConsultationDraft, error) {
	row := q.db.QueryRowContext(ctx, updateConsultationDraft,
		arg.ConsultationID,
		arg.ContactInfo,
		arg.BusinessContext,
		arg.PainPoints,
		arg.GoalsObjectives,
		arg.AutoSaved,
		arg.DraftNotes,
	)
	var i ConsultationDraft
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.AutoSaved,
		&i.DraftNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateConsultationStatus = `-- name: UpdateConsultationStatus :one
UPDATE consultations SET
    status = $2,
    completed_at = CASE WHEN $2 = 'completed' THEN CURRENT_TIMESTAMP ELSE completed_at END,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, contact_info, business_context, pain_points, goals_objectives, status, completion_percentage, created_at, updated_at, completed_at
`

type UpdateConsultationStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateConsultationStatus(ctx context.Context, arg UpdateConsultationStatusParams) (Consultation, error) {
	row := q.db.QueryRowContext(ctx, updateConsultationStatus, arg.ID, arg.Status)
	var i Consultation
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.Status,
		&i.CompletionPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const updateNote = `-- name: UpdateNote :one
update notes set title = $1, category = $2, content = $3 where id = $4 returning id, created, updated, user_id, title, category, content
`

type UpdateNoteParams struct {
	Title    string    `json:"title"`
	Category string    `json:"category"`
	Content  string    `json:"content"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) (Note, error) {
	row := q.db.QueryRowContext(ctx, updateNote,
		arg.Title,
		arg.Category,
		arg.Content,
		arg.ID,
	)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.Title,
		&i.Category,
		&i.Content,
	)
	return i, err
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions SET
    status = $2,
    canceled_at = CASE WHEN $2 = 'canceled' THEN CURRENT_TIMESTAMP ELSE canceled_at END,
    updated = CURRENT_TIMESTAMP
WHERE stripe_subscription_id = $1
RETURNING id, created, updated, user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, current_period_start, current_period_end, canceled_at
`

type UpdateSubscriptionStatusParams struct {
	StripeSubscriptionID string `json:"stripe_subscription_id"`
	Status               string `json:"status"`
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, updateSubscriptionStatus, arg.StripeSubscriptionID, arg.Status)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripePriceID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CanceledAt,
	)
	return i, err
}

const updateToken = `-- name: UpdateToken :exec
update tokens set expires = $1 where id = $2 returning id, expires, target, callback
`

type UpdateTokenParams struct {
	Expires time.Time `json:"expires"`
	ID      string    `json:"id"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) error {
	_, err := q.db.ExecContext(ctx, updateToken, arg.Expires, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :one
update users set
    email = $1,
    phone = $2,
    access = $3,
    avatar = $4,
    subscription_id = $5,
    subscription_end = $6,
    api_key = $7,
    updated = current_timestamp
where id = $8 returning id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key
`

type UpdateUserParams struct {
	Email           string    `json:"email"`
	Phone           string    `json:"phone"`
	Access          int64     `json:"access"`
	Avatar          string    `json:"avatar"`
	SubscriptionID  string    `json:"subscription_id"`
	SubscriptionEnd time.Time `json:"subscription_end"`
	ApiKey          string    `json:"api_key"`
	ID              uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Email,
		arg.Phone,
		arg.Access,
		arg.Avatar,
		arg.SubscriptionID,
		arg.SubscriptionEnd,
		arg.ApiKey,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
		&i.ApiKey,
	)
	return i, err
}

const updateUserAccess = `-- name: UpdateUserAccess :one
update users set access = $1 where id = $2 returning id, created, updated, email, phone, access, sub, avatar, customer_id, subscription_id, subscription_end, api_key
`

type UpdateUserAccessParams struct {
	Access int64     `json:"access"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserAccess(ctx context.Context, arg UpdateUserAccessParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserAccess, arg.Access, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.Email,
		&i.Phone,
		&i.Access,
		&i.Sub,
		&i.Avatar,
		&i.CustomerID,
		&i.SubscriptionID,
		&i.SubscriptionEnd,
		&i.ApiKey,
	)
	return i, err
}

const updateUserActivity = `-- name: UpdateUserActivity :exec
update users set updated = current_timestamp where id = $1
`

func (q *Queries) UpdateUserActivity(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, updateUserActivity, id)
	return err
}

const updateUserCustomerID = `-- name: UpdateUserCustomerID :exec
update users set customer_id = $1 where id = $2
`

type UpdateUserCustomerIDParams struct {
	CustomerID string    `json:"customer_id"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserCustomerID(ctx context.Context, arg UpdateUserCustomerIDParams) error {
	_, err := q.db.ExecContext(ctx, updateUserCustomerID, arg.CustomerID, arg.ID)
	return err
}

const updateUserPhone = `-- name: UpdateUserPhone :exec
update users set phone = $2 where id = $1
`

type UpdateUserPhoneParams struct {
	ID    uuid.UUID `json:"id"`
	Phone string    `json:"phone"`
}

func (q *Queries) UpdateUserPhone(ctx context.Context, arg UpdateUserPhoneParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPhone, arg.ID, arg.Phone)
	return err
}

const updateUserSubscription = `-- name: UpdateUserSubscription :exec
update users set access = $1, subscription_id = $2, subscription_end = $3 where customer_id = $4
`

type UpdateUserSubscriptionParams struct {
	Access          int64     `json:"access"`
	SubscriptionID  string    `json:"subscription_id"`
	SubscriptionEnd time.Time `json:"subscription_end"`
	CustomerID      string    `json:"customer_id"`
}

func (q *Queries) UpdateUserSubscription(ctx context.Context, arg UpdateUserSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSubscription,
		arg.Access,
		arg.SubscriptionID,
		arg.SubscriptionEnd,
		arg.CustomerID,
	)
	return err
}

const upsertConsultationDraft = `-- name: UpsertConsultationDraft :one
INSERT INTO consultation_drafts (
    id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT (consultation_id)
DO UPDATE SET
    contact_info = EXCLUDED.contact_info,
    business_context = EXCLUDED.business_context,
    pain_points = EXCLUDED.pain_points,
    goals_objectives = EXCLUDED.goals_objectives,
    auto_saved = EXCLUDED.auto_saved,
    draft_notes = EXCLUDED.draft_notes,
    updated_at = CURRENT_TIMESTAMP
RETURNING id, consultation_id, user_id, contact_info, business_context, pain_points, goals_objectives, auto_saved, draft_notes, created_at, updated_at
`

type UpsertConsultationDraftParams struct {
	ID              uuid.UUID       `json:"id"`
	ConsultationID  uuid.UUID       `json:"consultation_id"`
	UserID          uuid.UUID       `json:"user_id"`
	ContactInfo     json.RawMessage `json:"contact_info"`
	BusinessContext json.RawMessage `json:"business_context"`
	PainPoints      json.RawMessage `json:"pain_points"`
	GoalsObjectives json.RawMessage `json:"goals_objectives"`
	AutoSaved       bool            `json:"auto_saved"`
	DraftNotes      sql.NullString  `json:"draft_notes"`
}

func (q *Queries) UpsertConsultationDraft(ctx context.Context, arg UpsertConsultationDraftParams) (ConsultationDraft, error) {
	row := q.db.QueryRowContext(ctx, upsertConsultationDraft,
		arg.ID,
		arg.ConsultationID,
		arg.UserID,
		arg.ContactInfo,
		arg.BusinessContext,
		arg.PainPoints,
		arg.GoalsObjectives,
		arg.AutoSaved,
		arg.DraftNotes,
	)
	var i ConsultationDraft
	err := row.Scan(
		&i.ID,
		&i.ConsultationID,
		&i.UserID,
		&i.ContactInfo,
		&i.BusinessContext,
		&i.PainPoints,
		&i.GoalsObjectives,
		&i.AutoSaved,
		&i.DraftNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertSubscription = `-- name: UpsertSubscription :one
INSERT INTO subscriptions (
    user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id,
    status, current_period_start, current_period_end
) VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (stripe_subscription_id)
DO UPDATE SET
    stripe_price_id = EXCLUDED.stripe_price_id,
    status = EXCLUDED.status,
    current_period_start = EXCLUDED.current_period_start,
    current_period_end = EXCLUDED.current_period_end,
    updated = CURRENT_TIMESTAMP
RETURNING id, created, updated, user_id, stripe_customer_id, stripe_subscription_id, stripe_price_id, status, current_period_start, current_period_end, canceled_at
`

type UpsertSubscriptionParams struct {
	UserID               uuid.UUID `json:"user_id"`
	StripeCustomerID     string    `json:"stripe_customer_id"`
	StripeSubscriptionID string    `json:"stripe_subscription_id"`
	StripePriceID        string    `json:"stripe_price_id"`
	Status               string    `json:"status"`
	CurrentPeriodStart   time.Time `json:"current_period_start"`
	CurrentPeriodEnd     time.Time `json:"current_period_end"`
}

func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, upsertSubscription,
		arg.UserID,
		arg.StripeCustomerID,
		arg.StripeSubscriptionID,
		arg.StripePriceID,
		arg.Status,
		arg.CurrentPeriodStart,
		arg.CurrentPeriodEnd,
	)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Created,
		&i.Updated,
		&i.UserID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.StripePriceID,
		&i.Status,
		&i.CurrentPeriodStart,
		&i.CurrentPeriodEnd,
		&i.CanceledAt,
	)
	return i, err
}
